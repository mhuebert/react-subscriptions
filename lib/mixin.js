// Generated by CoffeeScript 1.6.1
(function() {
  var ReactAsync, async, fetchOnce, setSubscriptionStateCallback;

  ReactAsync = require("react-async");

  async = require("async");

  setSubscriptionStateCallback = function(owner, path, defaultData) {
    return function(data) {
      var state;
      state = {};
      state[path] = data || defaultData;
      return owner.setState(state);
    };
  };

  fetchOnce = function(subscription) {
    return function(callback) {
      return subscription.subscribe(function(data) {
        subscription.unsubscribe();
        return callback(null, data || subscription["default"]);
      });
    };
  };

  module.exports = {
    mixins: [ReactAsync.Mixin],
    subs: function(path) {
      var _base;
      return this.state[path] || (typeof (_base = this.constructor).subscriptions === "function" ? _base.subscriptions(this.props)[path]["default"] : void 0);
    },
    getInitialStateAsync: function(cb) {
      var path, subscription, subscriptions, tasks, _base;
      if (typeof window !== "undefined" && window !== null) {
        return;
      }
      this.__subscriptions = {};
      tasks = {};
      subscriptions = typeof (_base = this.constructor).subscriptions === "function" ? _base.subscriptions(this.props) : void 0;
      for (path in subscriptions) {
        subscription = subscriptions[path];
        this.__subscriptions[path] = subscription;
        tasks[path] = fetchOnce(subscription);
      }
      return async.parallel(tasks, function(err, results) {
        return cb(null, results);
      });
    },
    subscribe: function(props) {
      var path, subscription, _base, _ref, _results,
        _this = this;
      this.__subscriptions = {};
      _ref = typeof (_base = this.constructor).subscriptions === "function" ? _base.subscriptions(props) : void 0;
      _results = [];
      for (path in _ref) {
        subscription = _ref[path];
        _results.push((function(path, subscription) {
          subscription.subscribe(setSubscriptionStateCallback(_this, path, subscription["default"]));
          return _this.__subscriptions[path] = subscription;
        })(path, subscription));
      }
      return _results;
    },
    unsubscribe: function() {
      var path, subscription, _ref, _results;
      _ref = this.__subscriptions;
      _results = [];
      for (path in _ref) {
        subscription = _ref[path];
        subscription.unsubscribe();
        _results.push(delete this.__subscriptions[path]);
      }
      return _results;
    },
    componentDidMount: function() {
      return this.subscribe(this.props);
    },
    componentWillUnmount: function() {
      return this.unsubscribe();
    },
    componentWillReceiveProps: function(newProps) {
      var newSubscriptions, path, pathsToUpdate, subscription, _i, _len, _ref, _results;
      pathsToUpdate = [];
      _ref = this.__subscriptions;
      for (path in _ref) {
        subscription = _ref[path];
        if (typeof subscription.shouldUpdateSubscription === "function" ? subscription.shouldUpdateSubscription(this.props, newProps) : void 0) {
          pathsToUpdate.push(path);
        }
      }
      if (pathsToUpdate.length > 0) {
        newSubscriptions = this.constructor.subscriptions(newProps);
        _results = [];
        for (_i = 0, _len = pathsToUpdate.length; _i < _len; _i++) {
          path = pathsToUpdate[_i];
          this.__subscriptions[path].unsubscribe();
          this.__subscriptions[path] = newSubscriptions[path];
          _results.push(this.__subscriptions[path].subscribe(setSubscriptionStateCallback(this, path)));
        }
        return _results;
      }
    }
  };

}).call(this);
